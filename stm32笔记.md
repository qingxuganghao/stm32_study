#20217/20 第六节下 ——寄存器映射

一、1.三条总线及其基地址：APB1-基地址0x4000 0000   APB2-0x4001 0000   AHB-0x4001 8000（根据速度划分）

2.先找到总线的基地址，由基地址加上某个寄存器外设的偏移地址，可以找到某个寄存器外设的基地址。（总线基地址+寄存器外设偏移地址=外设基地址）

3.由寄存器相对于外设的基地址，可以算出外设绝对的地址.然后就可以通过c语言指针访问某个寄存器.

二、c语言对寄存器的封装

1.先对总线和外设基地址宏定义

（1）先定义外设基地址（外设的地址就等于APB1的地址，从APB1开始）（2）定义总线基地址（外设基地址加其偏移）（3）定义GPIO外设基地址（APB2+ABCDEFG的对应的偏移地址）（4）具体某个外设寄存器绝对地址（  GPIO基地址加上具体寄存器对应偏移）

2.用指针操作* (unsigned int*)

3.GPIOB_ODR &= ~(1<<0)//让PB0输出低电平；（取反相与实现清零）

GPIO_ODR |= (1<<0)//让PB0输出高电平；（置1相加实现高电平）

（1<<0左移0位——则为PB0；“|”相或 ； "~"取反；"&"相与）

三、使用结构体封装寄存器列表或使用结构体指针访问寄存器



#2021/7/18 第六节——寄存器

1.看丝印，辨别芯片正正方向

2.stm32系统框图——内部驱动单元cpu

四个被动单元：内部SRAM用来存取数据； flash用来存程序；FSMC特殊外设用来驱动外存；AHB——APB系统总线。

3总线： ICode——程序执行总线；DCode——数据总线；DMA——也可以读取数据；System——用来读取外设寄存器.

4.可以用const将数据常量放到内部flash中。

5.变量都放在内部SRAM中；

6.总线矩阵——当DMA和Dcode读取发生冲突时，仲裁.

7.DMA主要用来搬数据，可以让SRAM里面的数据不通过cpu直接搬到外设里面，这样可以加快速率不占cpu。

8.AHB上挂载有SDIO和RCC（复位和时钟控制）

9.APB分为APB1（高速总线）（有GPIO）和APB2（低速总线）（有定时器和串口）.

10.ARM为32位——4G内存，分为了8块，每一块512M。block0用来放flash；block1放SRAM；block2放外设寄存器；block3.4放FSMC；block5时FSMC寄存器，block6没有用；block7放内核的寄存器外设。

![img](file:///C:\Users\76170\AppData\Local\Temp\ksohtml16160\wps1.jpg) 

11. c语言里面*代表取地址。
12. (unsigned int*)——强制类型转换为地址.
13. STM32和51不同——没有<reg32.h>需要自己找寄存器对应地址.只能通过指针来操作.

